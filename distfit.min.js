require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * Helper method to compute the arithmetic mean of a vector of values
 * @function
 * @param {array} data - The sample
 * @returns {float} - The mean of the supplied sample
 */
var arithMean = exports.arithMean = function(data) {
  var sum = 0;
  var n = data.length;
  var i;
  for (i = 0; i < n; i++) {
    sum += data[i];
  }
  return sum / n;
};

var sampleStdDev = exports.sampleStdDev = function(data) {
  var n = data.length;
  var mean = arithMean(data);
  var sum = 0;
  var i;
  for (i = 0; i < n; i++) {
    sum += Math.pow((data[i] - mean), 2);
  }
  return Math.sqrt(sum / (n-1));
};

/**
 * @function
 */
var factorial = exports.factorial = function(n) {
  var res = 1;
  var i;
  for (i = 2; i <= n; i++) {
    res *= i;
  }
  return res;
};

/**
 * The abstract base class that represents a particular instance of a distribution
 * @constructor
 * @param {float=} mean - The mean of the distribution (if it has one)
 * @param {float=} variance - The variance of the distribution (if it has one)
 */
var Distribution = exports.Distribution = function(mean, variance) {
  this.mean = mean;
  this.variance = variance;
};

/**
 * The distribution is uniquely determined if it has all the parameters it
 * requires to compute all other quantities of interest.
 * @function
 * @abstract
 * @returns {bool} - true if this distribution is uniquely determined, false otherwise
 */
Distribution.prototype.isUniquelyDetermined = function() {
};

/**
 * Method to fit distribution to data.
 * @abstract
 */
Distribution.prototype.fitData = function() {
};

/**
 * The abstract base class for continuous distributions
 * @augments Distribution
 * @constructor
 * @param {float=} mean - The mean of the distribution (if it has one)
 * @param {float=} variance - The variance of the distribution (if it has one)
 */
var ContinuousDistribution = exports.ContinuousDistribution = function(mean, variance) {
  Distribution.call(this);
  this.mean = mean;
  this.variance = variance;
};

/**
 * The cumulative probability distribution function of the parametrised distribution.
 * @abstract
 * @function
 */
Distribution.prototype.cdf = function() {
};

/**
 * The probability density function of the parametrised distribution.
 * @abstract
 * @function
 */
ContinuousDistribution.prototype.pdf = function() {
};

/**
 * The abstract base class for discrete distributions
 * @augments Distribution
 * @constructor
 * @param {float=} mean - The mean of the distribution (if it has one)
 * @param {float=} variance - The variance of the distribution (if it has one)
 */
var DiscreteDistribution = exports.DiscreteDistribution = function(mean, variance) {
  Distribution.call(this);
  this.mean = mean;
  this.variance = variance;
};

/**
 * The probability mass function of the parametrised distribution.
 * @abstract
 * @function
 */
DiscreteDistribution.prototype.pmf = function() {
};

/*
 * erf.js authored by John D. Cook, as part of the picomath library.
 * Translated into JS by Greg Hewgill
 * See: http://picomath.org/index.html
 * Specifically: http://picomath.org/javascript/erf.js.html
 * It is in the public domain and its inclusion here is justified.
 */
var erf = exports.erf = function(x) {
  // constants
  var a1 =  0.254829592;
  var a2 = -0.284496736;
  var a3 =  1.421413741;
  var a4 = -1.453152027;
  var a5 =  1.061405429;
  var p  =  0.3275911;

  // Save the sign of x
  var sign = 1;
  if (x < 0) {
    sign = -1;
  }
  x = Math.abs(x);

  // A&S formula 7.1.26
  var t = 1.0/(1.0 + p*x);
  var y = 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);

  return sign*y;
};

},{}],2:[function(require,module,exports){
var core = require("./core");

/**
 * The constructor for a Exponential distribution object
 * @constructor
 * @augments ContinuousDistribution
 * @param {float=} lambda - Rate (inverse scale) parameter
 */
var Exponential = exports.Exponential = function(lambda) {
  this.lambda = lambda;
  this.mean = this.variance = undefined;
  if (lambda !== undefined)
    this.setLambda(lambda);
};
Exponential.prototype = Object.create(core.ContinuousDistribution.prototype);
Exponential.prototype.constructor = Exponential;

/**
 * Compute the Uniformly Minimum Variance Unbiased Estimator of lambda
 * @function
 * @param {array} data - The data from which to compute the UMVUE lambda estimator
 */
Exponential.computeLambdaUMVUE = exports.Exponential.computeLambdaUMVUE = function(data) {
  var xbar = core.arithMean(data);
  var n = data.length;
  var umvue = ((n-1)/n)*Math.pow(xbar, -1);
  return umvue;
};

/**
 * Compute the Mean Square Error-minimising estimator of lambda
 * @function
 * @param {array} data - The data from which to compute lambda
 */
Exponential.computeLambdaMinMSE = exports.computeLambdaMinMSE = function(data) {
  var xbar = core.arithMean(data);
  var n = data.length;
  var minMSEEstimator = ((n-2)/n)*Math.pow(xbar, -1);
  return minMSEEstimator;
};

/**
 * Fits distribution to supplied data. Note: defaults to Uniform Min-Variance Unbiased Estimator!
 * @function
 * @param {array} data - The data to which this distribution will be fitted
 */
Exponential.prototype.fitData = function(data) {
  core.ContinuousDistribution.call(this);
  var lambda = Exponential.computeLambdaUMVUE(data);
  this.setLambda(lambda);
};

/**
 * @function
 * @param {float} lambda - The lambda with which to parametrise this distribution
 */
Exponential.prototype.setLambda = function(lambda) {
  this.lambda = lambda;
  this.mean = Math.pow(lambda, -1);
  this.variance = Math.pow(lambda, -2);
};

/**
 * @inheritdoc
 */
Exponential.prototype.isUniquelyDetermined = function() {
  return this.lambda !== undefined && this.lambda !== 0;
};

/**
 * @inheritdoc
 */
Exponential.prototype.pdf = function(x) {
  return this.lambda * Math.exp(-this.lambda * x);
};

/**
 * @inheritdoc
 */
Exponential.prototype.cdf = function(x) {
  return 1 - Math.exp(-this.lambda * x);
};

},{"./core":1}],3:[function(require,module,exports){
var core = require("./core");

var Kernel = exports.Kernel = function() {
};

Kernel.Gaussian = exports.Kernel.Gaussian = function(u) {
  return (1/Math.sqrt(2*Math.PI)) * Math.exp((-1/2) * Math.pow(u,2));
};

var KDEDist = exports.KDEDist = function(kernel, data) {
  this.kernel = kernel;
  this.data = data;
  this.fitData(data);
};
KDEDist.prototype = Object.create(core.Distribution.prototype);
KDEDist.prototype.constructor = KDEDist;

/**
 * Bandwidth estimation using Silverman's rule of thumb
 * @function
 */
KDEDist.silverman = function(sigmahat, n) {
  return Math.pow(4 * Math.pow(sigmahat, 5) / (3 * n), (1/5));
};

/**
 * @inheritdoc
 */
KDEDist.prototype.fitData = function(data) {
  this.n = data.length;
  this.data = data;
  this.sigmahat = core.sampleStdDev(data);
  this.bw = KDEDist.silverman(this.sigmahat, this.n);
};

/**
 * @inheritdoc
 */
KDEDist.prototype.pdf = function(x) {
  var sum = 0;
  var kernel = this.kernel;
  var bw = this.bw;
  this.data.forEach(function(xi) {
    var pt = (x-xi)/bw;
    sum += kernel(pt);
  });
  return Math.pow(this.n * this.bw, -1) * sum;
};

},{"./core":1}],4:[function(require,module,exports){
var core = require("./core");
/**
 * The constructor for a Normal Distribution object
 * @constructor
 * @augments ContinuousDistribution
 * @param {float=} mu - Mean
 * @param {float=} sigma2 - Variance
 */
var Normal = exports.Normal = function(mu, sigma2) {
  this.mu = mu;
  this.sigma2 = sigma2;
  this.mean = this.mu;
  this.variance = this.sigma2;
};
Normal.prototype = Object.create(core.ContinuousDistribution.prototype);
Normal.prototype.constructor = Normal;

/**
 * Helper function to compute parameter mu for the Normal
 * @function
 * @param {array} data - the data from which to compute mu
 */
Normal.computeMu = exports.Normal.computeMu = function(data) {
  return core.arithMean(data);
};

/**
 * Helper function to compute parameter sigma2 for the Normal
 * @function
 * @param {array} data - the data from which to compute sigma2
 * @param {float=} mu - The mean
 */
Normal.computeSigma2 = exports.Normal.computeSigma2 = function(data, mu) {
  mu = mu || Normal.computeMu(data);
  var sumOfSquaredDiffs = 0;
  var n = data.length;
  var i;
  for (i = 0; i < n; i++) {
    var squaredDiff = Math.pow(data[i]-mu, 2);
    sumOfSquaredDiffs += squaredDiff;
  }
  var sigma2 = sumOfSquaredDiffs / n;
  return sigma2;
};

/**
 * @inheritdoc
 */
Normal.prototype.fitData = function(data) {
  core.ContinuousDistribution.call(this);
  this.mu = Normal.computeMu(data);
  this.sigma2 = Normal.computeSigma2(data, this.mu);
  this.mean = this.mu;
  this.variance = this.sigma2;
};

/**
 * @inheritdoc
 */
Normal.prototype.isUniquelyDetermined = function() {
  var validMean = (this.mu !== undefined);
  var validVariance = (this.sigma2 !== undefined && this.sigma2 > 0);
  return (validMean && validVariance);
};

/**
 * @inheritdoc
 */
Normal.prototype.pdf = function(x) {
  var sigma = Math.sqrt(this.sigma2);
  var normalisingConstant = Math.pow(sigma * Math.sqrt(2*Math.PI), -1);
  var argument = -Math.pow(x-this.mu, 2) / (2 * this.sigma2);
  return normalisingConstant * Math.exp(argument);
};

/**
 * @inheritdoc
 */
Normal.prototype.cdf = function(x) {
  var s = (x-this.mu)/Math.sqrt(this.sigma2);
  var prob = (1/2) * (1 + core.erf(s/Math.sqrt(2)));
  return prob;
};

},{"./core":1}],5:[function(require,module,exports){
var core = require("./core");

/**
 * The constructor for a Poisson distribution object
 * @constructor
 * @augments DiscreteDistribution
 * @param {float=} lambda - Rate parameter
 */
var Poisson = exports.Poisson = function(lambda) {
  this.lambda = lambda;
  this.mean = lambda;
  this.variance = lambda;
};
Poisson.prototype = Object.create(core.DiscreteDistribution.prototype);
Poisson.prototype.constructor = Poisson;

/**
 * Helper function to compute parameter lambda for Poisson distribution
 * @function
 * @param {array} data - The data from which to compute lambda
 */
Poisson.computeLambda = exports.Poisson.computeLambda = function(data) {
  // The MLE estimator used here is of minimum variance and unbiased.
  var lambda = core.arithMean(data);
  return lambda;
};


/**
 * @inheritdoc
 */
Poisson.prototype.isUniquelyDetermined = function() {
  return this.lambda !== undefined;
};

/**
 * @inheritdoc
 */
Poisson.prototype.fitData = function(data) {
  core.DiscreteDistribution.call(this);
  var lambda = Poisson.computeLambda(data);
  this.lambda = this.mean = this.variance = lambda;
};

/**
 * @inheritdoc
 */
Poisson.prototype.pmf = function(x) {
  return Math.pow(this.lambda, x) * Math.exp(-this.lambda) / core.factorial(x);
};

/**
 * @inheritdoc
 */
Poisson.prototype.cdf = function(x) {
  var total = 0;
  var k;
  for (k = 0; k <= x; k++) {
      var probMass_k = this.pmf(k);
      total += probMass_k;
  }
  return total;
};

},{"./core":1}],"distfit":[function(require,module,exports){
var Normal = module.exports.Normal = require("./normal").Normal;
var Poisson = module.exports.Poisson = require("./poisson").Poisson;
var Exponential = module.exports.Exponential = require("./exponential").Exponential;
var KDE = module.exports.KDE = require("./kde");

},{"./exponential":2,"./kde":3,"./normal":4,"./poisson":5}]},{},[]);
